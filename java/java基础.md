### jdk安装
1. 配置JAVA_HOME
2. %...%，表示window下的取路径
3. classpath 给JVM用的——找到classpath后面加分号

### 关键字和标识符的本质区别是什么
1. 关键字是编译器保留用作它用的token字，如int, void, unsigned。而标识符一般作为c语言变量和函数名而自定义的，并且有一定的命名规则——以字母或_开头，只包含数字，字母，$, _ 等。

### 类型默认
1. 整数int
2. 浮点double,想转为float后面加f,如5f

### 编译
1. 编译只检查语法，即使有错误，只要符合语法就不报错

### 移位
1. >>、<<、>>>可用于除2运算

### 逻辑符号
1. &|等，用于置0置1操作
2. ^可用于加密，由于对同一个数异或两次为其本身；1.还可用于从一堆数字（共有2n+1个，包含n+1个不同的数字，n个数字出现2次，只有一个数字出现1次）找出出现1次的数字；2.亦可用于不用任何辅助空间交换两个变量的内容

### 构造代码块的作用
1. 和构造函数的作用类似，都能对对象进行初始化，并且只要创建一个对象，构造代码块都会执行一次。但是反过来，构造函数则不一定每个对象建立时都执行（多个构造函数情况下，建立对象时传入的参数不同则初始化使用对应的构造函数）。
2. 利用每次创建对象的时候都会提前调用一次构造代码块特性，我们可以做诸如统计创建对象的次数等功能。

### 创建对象流程
1. 加载指定字节码文件进内存
2. 通过new在堆内存中开辟空间，分配首地址
3. 对对象中的属性进行默认初始化
4. 调用**与之对应的构造函数***构造函数压栈
5. 执行隐式super()——若没有无参构造方法，那么必须显式调用父类的构造方法
```java
public class Construct {
    int i;
    int j;
    public Construct(int i) {
        System.out.println("一个参数");
        this.i = i;
    }
//    public Construct() {
//        System.out.println("没有参数");
//    }
    public static void main(String[] args){
        Son s = new Son();
        System.out.println(s.hashCode());
    }
}
class Son extends Construct{
    public Son() {
        super(3); //若无显式调用，必定报错
        System.out.println("son的构造方法");
    }
}
```
6. 对属性显式初始化
7. 调用类中构造代码块
8. 执行构造函数自定义的初始化代码
9. 初始化完毕，降低至付给指定引用

#### Java的四个基本特性 
1. 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。
抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。比如：机车会跑，这个跑就是一个抽象
2. 继承：继承是从父类（超类、基类）得到继承信息创建新类的过程。继承让变化中的软件系统有了一定的延续性，
同时继承也是封装程序中可变因素的重要手段。子类可以对父类的方法进行覆写或对其已有方法的补充
3. 封装：封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。比如：程序员会写代码，就告诉了外界这一个信息，
至于他是怎么写的外界不需要知道，只需要调用就好
4. 多态：是指允许不同类型的对象对同一消息作出不同的响应

### 多态的理解(多态的实现方式) 
1. 方法重载（overload）实现的是编译时的多态性（也称为前绑定）。 
2. 方法重写（override）实现的是运行时的多态性（也称为后绑定）。运行时的多态是面向对象最精髓的东西
3. Java实现多态有三个必要条件：继承、重写、向上转型。

### Java初始化的顺序
**原则** 
1. 静态对象（变量）优于非静态对象（变量），静态初始化一次，而非静态可能会初始化多次
2. 父类先于子类
3. 按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化

### HashMap和HashTable的区别
1. Hashtable的方法是同步的，HashMap未经同步
2. Hashtable不允许 null 值(key 和 value 都不可以)，HashMap允许 null 值(key和value都可以)但只需有一个 
3. 两者的遍历方式大同小异，Hashtable仅仅比HashMap多一个elements方法。 
4. Hashtable和HashMap都能通过values()方法返回一个Collection，然后进行遍历处理。 
5. 两者也都可以通过 entrySet() 方法返回一个 Set，然后进行遍历处理。 
6. HashTable使用Enumeration，HashMap使用Iterator。 
7. 哈希值的使用不同，Hashtable直接使用对象的hashCode。而HashMap重新计算hash值，而且用于代替求模。 
8. Hashtable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 
9. HashTable基于Dictionary类，而HashMap基于AbstractMap类 

###Java实现多线程的方式
1. 继承Thread类，重写run函数。 
2. 实现Runnable接口 
3. 实现Callable接口   
**区别**  
1. 实现Runnable接口可以避免Java单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，
代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。 
2. 继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法。 
3. 实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他的两种都是重写run方法，没有返回值。 

###多线程共用一个数据变量需要注意什么？ 
1. 当我们在线程对象（Runnable）中定义了全局变量，run方法会修改该变量时，如果有多个线程同时使用该线程对象，那么就会造成全局变量的值被同时修改，造成错误. 
2. ThreadLocal是JDK引入的一种机制，它用于解决线程间共享变量，使用ThreadLocal声明的变量，即使在线程中属于全局变量，针对每个线程来讲，这个变量也是独立的。 
3. volatile变量每次被线程访问时，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改变化时，也会强迫线程将最新的值刷新回主内存中。
这样一来，不同的线程都能及时的看到该变量的最新值。 

###Java中的NIO，BIO，AIO分别是什么？  
1. BIO  
    同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，
	如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。  
    BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高
2. NIO   
    同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。   
    NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器 
3. AIO  
    异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.   
    AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。